# Rust Competitive Programming Template

A comprehensive Rust template for competitive programming with modular development structure and single-file submission support.

## ğŸš€ Quick Start for Competitive Programming

### For Online Judges (Codeforces, AtCoder, etc.)

1. **Copy the single-file template**: Use `template_simple.rs` for submissions
2. **Implement your solution** in the `solve()` function
3. **Submit the entire file** to the online judge

```rust
fn solve(reader: &mut dyn BufRead) {
    let n: usize = read(reader);
    let arr: Vec<i32> = read_vec(reader);
    
    // Your solution here
    println!("{}", arr.iter().sum::<i32>());
}
```

### For Development and Testing

1. **Use the modular structure** in `src/` for development
2. **Run tests**: `cargo test`
3. **Generate single file**: `python build_single_file.py`

## ğŸ“ Project Structure

```
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs              # Development template with examples
â”‚   â”œâ”€â”€ lib.rs               # Library exports
â”‚   â”œâ”€â”€ prelude.rs           # Common imports and macros
â”‚   â”œâ”€â”€ io/mod.rs            # I/O utilities
â”‚   â”œâ”€â”€ math/mod.rs          # Mathematical functions
â”‚   â”œâ”€â”€ data_structures/mod.rs # Data structures (UnionFind, Fenwick, etc.)
â”‚   â”œâ”€â”€ graph/mod.rs         # Graph algorithms
â”‚   â”œâ”€â”€ string/mod.rs        # String algorithms
â”‚   â”œâ”€â”€ geometry/mod.rs      # Geometry utilities
â”‚   â””â”€â”€ utils/mod.rs         # Utility functions
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ integration_tests.rs # Comprehensive integration tests
â”œâ”€â”€ template_simple.rs       # Single-file template for submissions
â”œâ”€â”€ build_single_file.py     # Script to generate single-file templates
â””â”€â”€ README.md               # This file
```

## ğŸ› ï¸ Available Templates

### 1. `template_simple.rs` (Recommended for most problems)
- **Size**: ~8KB
- **Compilation time**: Fast
- **Includes**: Essential utilities only
- **Best for**: Most competitive programming problems

### 2. Full template (generated by `build_single_file.py`)
- **Size**: ~70KB
- **Compilation time**: Slower
- **Includes**: All implemented algorithms and data structures
- **Best for**: Complex problems requiring multiple algorithms

### 3. Modular development structure
- **Best for**: Development, testing, and learning
- **Use**: `cargo run`, `cargo test`

## ğŸ“š Available Utilities

### I/O Functions
```rust
let n: usize = read(reader);                    // Read single value
let arr: Vec<i32> = read_vec(reader);          // Read vector
let (a, b) = read_tuple!(reader, i64, i64);    // Read tuple
let matrix = read_matrix(reader, rows);         // Read 2D matrix
```

### Math Functions
```rust
gcd(a, b)                    // Greatest common divisor
lcm(a, b)                    // Least common multiple
mod_pow(base, exp, mod)      // Modular exponentiation
mod_inv(a, mod)              // Modular inverse
```

### Data Structures
```rust
let mut uf = UnionFind::new(n);        // Union-Find
let mut ft = FenwickTree::new(n);      // Fenwick Tree (BIT)
let mut graph = Graph::new(n);         // Graph
```

### Utility Functions
```rust
lower_bound(&arr, &target)   // Binary search lower bound
upper_bound(&arr, &target)   // Binary search upper bound
```

### Constants
```rust
MOD = 1_000_000_007         // Common modulo
MOD2 = 998_244_353          // Alternative modulo
INF = 1_000_000_000_000_000_000  // Large number
EPS = 1e-9                  // Small epsilon for floating point
DX4, DY4                    // 4-directional movement vectors
```

## ğŸ¯ Usage Examples

### Single Test Case
```rust
fn solve(reader: &mut dyn BufRead) {
    let n: usize = read(reader);
    let arr: Vec<i32> = read_vec(reader);
    
    let sum: i32 = arr.iter().sum();
    println!("{}", sum);
}

fn main() {
    let mut reader = init_reader();
    solve(&mut reader);
}
```

### Multiple Test Cases
```rust
fn main() {
    let mut reader = init_reader();
    let t: usize = read(&mut reader);
    for _ in 0..t {
        solve(&mut reader);
    }
}
```

### Using Data Structures
```rust
fn solve(reader: &mut dyn BufRead) {
    let n: usize = read(reader);
    
    // Union-Find example
    let mut uf = UnionFind::new(n);
    uf.union(0, 1);
    println!("{}", uf.connected(0, 1)); // true
    
    // Fenwick Tree example
    let mut ft = FenwickTree::new(n);
    ft.update(0, 5);
    ft.update(2, 3);
    println!("{}", ft.range_sum(0, 2)); // 8
    
    // Graph example
    let mut graph = Graph::new(n);
    graph.add_edge(0, 1);
    let distances = graph.bfs(0);
}
```

## ğŸ§ª Testing

### Run all tests
```bash
cargo test
```

### Run specific test module
```bash
cargo test --test integration_tests
```

### Test the single-file template
```bash
rustc template_simple.rs -o template_simple
echo "5\n1 2 3 4 5" | ./template_simple
```

## ğŸ”§ Development Workflow

1. **Develop** using the modular structure in `src/`
2. **Test** your algorithms with `cargo test`
3. **Generate** single-file template when ready to submit
4. **Copy** the relevant parts to your submission file
5. **Submit** to the online judge

## ğŸ“ Customization

### Adding New Algorithms
1. Add to appropriate module in `src/`
2. Export in `src/lib.rs`
3. Add to `src/prelude.rs` if commonly used
4. Update `build_single_file.py` if needed

### Creating Custom Templates
Modify `template_simple.rs` to include only the utilities you need for specific types of problems.

## ğŸ† Competitive Programming Tips

1. **Start with `template_simple.rs`** for most problems
2. **Use the macro `read_tuple!`** for reading multiple values
3. **Prefer `Vec<T>` over arrays** for dynamic sizing
4. **Use `BufRead`** for fast I/O
5. **Test locally** before submitting
6. **Keep templates small** for faster compilation on judges

## ğŸ¤ Contributing

Feel free to add more algorithms, optimize existing ones, or improve the template structure!

## ğŸ“„ License

This template is provided as-is for competitive programming use. Feel free to modify and distribute.